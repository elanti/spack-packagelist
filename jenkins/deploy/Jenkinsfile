pipeline {
    agent {
        label 'fidis-login'
    }


    // Adds timestamps to console logs
    options {
        timestamps()
    }


    environment {
        STACK_RELEASE = "arvine"
        SENV_VIRTUALENV_PATH = "/home/scitasbuild/${STACK_RELEASE}/virtualenv/senv-py36"
        SPACK_CHECKOUT_DIR = "${sh(script:'jenkins/senv.sh spack-checkout-dir', returnStdout: true).trim()}"
        SPACK_RELEASE = "${sh(script:'jenkins/senv.sh spack-release', returnStdout: true).trim()}"
        DRY_RUN= "yes"
    }

    stages {
        when {
            expression { BRANCH_NAME ==~ /(releases\/${STACK_RELEASE}|.*\/${STACK_RELEASE}\/.*)/ }
        }

        stage('Check environment') {
            steps {
                sh 'env'
            }
        }

    //     stage('Update production configuration') {
    //         // Prepare a release branch of Spack for deployment by:
    //         //
    //         // 1. Updating the tracked branch
    //         // 2. Updating our internal Spack repository
    //         // 3. Copying the latest configuration files in place
    //         //
    //         steps {
    //             // Checkout Spack
    //             sh 'jenkins/senv.sh spack-checkout'

    //             // Checkout extra packages sources;
    //             sh 'jenkins/senv.sh spack-checkout-extra-repos'

    //             // Update the command line tool we use in production
    //             // and configuration files
    //             sh 'jenkins/deploy/scripts/update_production_configuration.sh'
    //         }
    //     }

    //     stage('Prepare production stack') {
    //         // Ensure that all the compilers that are needed in
    //         // production are in place.
    //         prepare_compilers()
    //     }

    //     stage('Populate mirror') {
    //         // Compute what needs to be installed in production (software that
    //         // is part of the planned environment, but not installed yet). Then
    //         // retrieve all the resources (tarballs, etc.) that are needed
    //         // to build it in a mirror.
    //         // TODO: the agent below must have access to the network
    //         steps {
    //             sh 'jenkins/deploy/scripts/populate_mirror.sh'
    //         }
    //     }

    //     stage('Deploy software') {
    //         // Deploy the software that is planned to be in the environment,
    //         // but not yet installed. Notify failures.
    //         deploy_envs()
    //     }
    }
}

def checkout_extra_dirs() {
    list_repositories =  readYaml text: (sh (script: 'jenkins/senv.sh list-extra-repositories').trim())

    list_repositories.each {
        dir(it.path) {
            git url: it.repo
        }
    }
}

def prepare_compilers() {
    environments = sh (script: "jenkins/scripts/deploy/senv.sh --list-envs --input ${STACK_RELEASE}.yaml").trim()
    def tests = [:]
    for (environment in environments) {
        slurm_version = "${sh(script:'jenkins/senv.sh get-environment-entry --env ${environment} slurm', returnStdout: true).trim().split('.')[0,1].join('')}"
        os_version = "${sh(script:'jenkins/senv.sh get-environment-entry --env ${environment} os', returnStdout: true).trim()}"

        tests = stage("${environment}-${STACK_RELEASE}-${os_version}-${slurm_version}") {
            agent {
                label '${environment}'
            }
            steps {
                sh  'jenkins/deploy/scripts/install_production_compilers.sh ${environment}'
            }
            post {
                always {
                    archiveArtifacts artifacts:'*.txt, *.xml'
                    junit testResults:'*.xml', allowEmptyResults:true
                }
                failure {
                    mattermostSend color: 'warning', message: 'Prepare production stack failed for ${environment}. ${env.BUILD_URL}'
                }
            }
        }
    }
    parallel tests
}

def deploy_envs() {
    environments = sh (script: "jenkins/scripts/deploy/senv.sh --list-envs --input ${STACK_RELEASE}.yaml").trim()
    def tests = [:]
    for (environment in environments) {
        slurm_version = "${sh(script:'jenkins/senv.sh get-environment-entry --env ${environment} slurm', returnStdout: true).trim().split('.')[0,1].join('')}"
        os_version = "${sh(script:'jenkins/senv.sh get-environment-entry --env ${environment} os', returnStdout: true).trim()}"

        tests = stage("${environment}-${STACK_RELEASE}-${os_version}-${slurm_version}") {
            agent {
                label '${environment}'
            }
            steps {
                sh  'jenkins/deploy/scripts/install_production_stack.sh ${environment}'
            }
            post {
                always {
                    archiveArtifacts artifacts:'*.txt, *.xml'
                    junit testResults:'*.xml', allowEmptyResults:true
                }
                failure {
                    mattermostSend color: 'warning', message: 'Deployement of production stack failed for ${environment}. ${env.BUILD_URL}'
                }
            }
        }
    }
    parallel tests
}
