pipeline {
    agent {
        label 'fidis-login'
    }

    // Adds timestamps to console logs
    options {
        timestamps()
    }

    environment {
        STACK_RELEASE = "arvine"
        SENV_VIRTUALENV_PATH = "/home/scitasbuild/${STACK_RELEASE}/virtualenv/senv-py36"
        DRY_RUN= "yes"
    }

    stages {
        stage('Update production configuration') {
            // Prepare a release branch of Spack for deployment by:
            //
            // 1. Updating the tracked branch
            // 2. Updating our internal Spack repository
            // 3. Copying the latest configuration files in place
            //
            steps {
                // Update the command line tool we use in production
                // and configuration files
                sh 'jenkins/deploy/scripts/update_production_configuration.sh'

                // Check that senv is operational
                sh 'jenkins/senv.sh status'

                // Checkout Spack
                sh 'jenkins/senv.sh spack-checkout'

                // Checkout extra packages sources;
                sh 'jenkins/senv.sh spack-checkout-extra-repos'
            }
        }
        stage('Check environment') {
            environment {
                SPACK_CHECKOUT_DIR = "${sh(script:'jenkins/senv.sh spack-checkout-dir', returnStdout: true).trim()}"
            }
            steps {
                sh 'env | sort'
            }
        }

        stage('Prepare production stack') {
            environment {
                SPACK_CHECKOUT_DIR = "${sh(script:'jenkins/senv.sh spack-checkout-dir', returnStdout: true).trim()}"
            }

            // Ensure that all the compilers that are needed in
            // production are in place.
            steps {
                script {
                    parallel(prepare_compilers())
                }
            }
        }

    //     stage('Populate mirror') {
    //         // Compute what needs to be installed in production (software that
    //         // is part of the planned environment, but not installed yet). Then
    //         // retrieve all the resources (tarballs, etc.) that are needed
    //         // to build it in a mirror.
    //         // TODO: the agent below must have access to the network
    //         steps {
    //             sh 'jenkins/deploy/scripts/populate_mirror.sh'
    //         }
    //     }

    //     stage('Deploy software') {
    //         // Deploy the software that is planned to be in the environment,
    //         // but not yet installed. Notify failures.
    //         deploy_envs()
    //     }
    }
}


def get_agent_name(environment) {
    env.environment = environment
    slurm_version_ = sh (
        script: 'jenkins/senv.sh get-environment-entry --env ${environment} environment.slurm  | sed -e \'s/\\([0-9]*\\)\\.\\([0-9]*\\).*/\\1\\2/\'',
        returnStdout: true
    )
    slurm_version = slurm_version_.trim()
    os_version_ = sh (
            script:'jenkins/senv.sh get-environment-entry --env ${environment} environment.os',
            returnStdout: true
    )
    os_version = os_version_.trim()
    
    agent_name = "${environment}-${STACK_RELEASE}-${os_version}-slurm${slurm_version}"
    env.slurm_version = slurm_version
    env.os_version = os_version
    sh 'env | sort'
    return agent_name
}

def prepare_compilers() {
    environments = "${sh (script: 'jenkins/senv.sh --input ${STACK_RELEASE}.yaml list-envs', returnStdout: true).trim()}".split('\n')
    def tests = [:]
    for (environment in environments) {
        env.environment = environment
        agent_name = get_agent_name(environment)
        
        tests["compilers-${agent_name}"] = {
            stage("compilers-${agent_name}") {
                node(agent_name) {
                    sh  'pwd'
                    sh  'ls'
                    sh  'jenkins/deploy/scripts/install_production_compilers.sh ${environment}'
                }
            }
            post {
                always {
                    archiveArtifacts artifacts:'*.txt, *.xml'
                    junit testResults:'*.xml', allowEmptyResults:true
                }
                failure {
                    mattermostSend color: 'warning', message: 'Prepare production stack failed for ${environment}. ${env.BUILD_URL}'
                }
            }
        }
    }
    return tests
}

def deploy_envs() {
    environments = sh (script: "jenkins/senv.sh --input ${STACK_RELEASE}.yaml list-envs").trim().split('\n')
    def tests = [:]
    for (environment in environments) {
        agent_name = get_agent_name(environment)

        tests["deploy-${agent_name}"] = {
            stage("deploy-${agent_name}") {
                agent {
                    label '${agent_name}'
                }
                steps {
                    sh  'jenkins/deploy/scripts/install_production_stack.sh ${environment}'
                }
                post {
                    always {
                        archiveArtifacts artifacts:'*.txt, *.xml'
                        junit testResults:'*.xml', allowEmptyResults:true
                    }
                    failure {
                        mattermostSend color: 'warning', message: 'Deployement of production stack failed for ${environment}. ${env.BUILD_URL}'
                    }
                }
            }
        }
    }
    return tests
}
