pipeline {
    agent {
        label 'fidis-login'
    }

    // Adds timestamps to console logs
    options {
        timestamps()
    }

    environment {
        STACK_RELEASE = "arvine"
        SENV_VIRTUALENV_PATH = "/home/scitasbuild/${STACK_RELEASE}/virtualenv/senv-py27"
        DRY_RUN= "yes"
    }

    stages {
        stage('Update production configuration') {
            // Prepare a release branch of Spack for deployment by:
            //
            // 1. Updating the tracked branch
            // 2. Updating our internal Spack repository
            // 3. Copying the latest configuration files in place
            //
            steps {
                // Update the command line tool we use in production
                // and configuration files
                sh 'jenkins/deploy/scripts/update_production_configuration.sh'

                // Check that senv is operational
                sh 'jenkins/senv.sh status'

                // Checkout Spack
                sh 'jenkins/senv.sh spack-checkout'

                // Checkout extra packages sources;
                sh 'jenkins/senv.sh spack-checkout-extra-repos'
            }
        }
        stage('Check environment') {
            environment {
                SPACK_CHECKOUT_DIR = "${sh(script:'jenkins/senv.sh spack-checkout-dir', returnStdout: true).trim()}"
            }
            steps {
                sh 'env | sort'
            }
        }

        stage('Prepare production stack') {
            environment {
                SPACK_CHECKOUT_DIR = "${sh(script:'jenkins/senv.sh spack-checkout-dir', returnStdout: true).trim()}"
            }

            // Ensure that all the compilers that are needed in
            // production are in place.
            steps {
                script {
                    parallel(prepare_compilers())
                }
            }
        }

        stage('Populate mirror') {
            environment {
                SPACK_CHECKOUT_DIR = "${sh(script:'jenkins/senv.sh spack-checkout-dir', returnStdout: true).trim()}"
            }
            // TODO: the agent below must have access to the network
            steps {
                sh 'jenkins/deploy/scripts/populate_mirror.sh'
            }
        }

        stage('Deploy software') {
            // Deploy the software that is planned to be in the environment,
            // but not yet installed. Notify failures.
            steps {
                script {
                    parallel(prepare_compilers())
                }
            }
        }
    }
}

def get_agent_name(environment) {
    env.environment = environment
    slurm_version_ = sh (
        script: 'jenkins/senv.sh get-environment-entry --env ${environment} environment.slurm  | sed -e \'s/\\([0-9]*\\)\\.\\([0-9]*\\).*/\\1\\2/\'',
        returnStdout: true
    )
    slurm_version = slurm_version_.trim()

    os_version_ = sh (
            script:'jenkins/senv.sh get-environment-entry --env ${environment} environment.os',
            returnStdout: true
    )
    os_version = os_version_.trim()
    
    agent_name = "${environment}-${STACK_RELEASE}-${os_version}-slurm${slurm_version}"

    return agent_name
}

def _define_stages(prefix, script, message) {
    environments = "${sh (script: 'jenkins/senv.sh --input ${STACK_RELEASE}.yaml list-envs', returnStdout: true).trim()}".split('\n')
    env.script = script
    def jobs = [:]
    for (environment in environments) {
        env.environment = environment
        agent_name = get_agent_name(environment)

        jobs["${prefix}-${agent_name}"] = {
            stage("${prefix}-${agent_name}") {
                node(agent_name) {
                    result = ''
                    checkout scm
                    try {
                        sh  '${script} ${environment}'
                    } catch(error) {
                        result = error
                        currentBuild.result = 'FAILURE'
                        mattermostSend color: 'warning',
                            message: '${message} failed for ${environment}. ${env.BUILD_URL} with error ${error}'
                    }
                    archiveArtifacts artifacts:'*.txt, *.xml',
                        allowEmptyArchive: true
                    junit testResults:'*.xml',
                        allowEmptyResults: true
                    if (result) {
                        throw(error)
                    }
                }
            }
        }
    }
    return jobs
}

def prepare_compilers() {
    return _define_stages('compilers',
                          'jenkins/deploy/scripts/install_production_compilers.sh',
                          'Prepare production stack')
}

def deploy_envs() {
    return _define_stages('deploy',
                          'jenkins/deploy/scripts/install_production_stack.sh',
                          'Deployement of production stack')
}
